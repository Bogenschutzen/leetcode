#### [395. 至少有 K 个重复字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/)

难度`中等`

给你一个字符串 `s` 和一个整数 `k` ，请你找出 `s` 中的最长子串， 要求该子串中的每一字符出现次数都不少于 `k` 。返回这一子串的长度。

**示例 1：**

```
输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
```

**示例 2：**

```
输入：s = "ababbc", k = 2
输出：5
解释：最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
```

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由小写英文字母组成
- `1 <= k <= 105`

---

#### 滑动窗口

其实看到这道题，我第一反应是「二分」，直接「二分」答案。

但是往下分析就能发现「二分」不可行，因为不具有二段性质。

也就是假设有长度 `t` 的一段区间满足要求的话，`t + 1` 长度的区间是否「一定满足」或者「一定不满足」呢？

显然并不一定，是否满足取决于 `t + 1` 个位置出现的字符在不在原有区间内。

举个🌰吧，假设我们已经画出来一段长度为 `t` 的区间满足要求（且此时 k > 1），那么当我们将长度扩成 `t + 1` 的时候（无论是往左扩还是往右扩）：

- 如果新位置的字符在原有区间**出现过**，那必然还是满足出现次数大于 k，这时候 **`t + 1` 的长度满足要求**
- 如果新位置的字符在原有区间**没出现过**，那新字符的出现次数只有一次，这时候 **`t + 1` 的长度不满足要求**，但是如果之后连续出现该位置字符，导致该字符满足条件，那么又会出现满足条件的位置。
- 例如`aaabbbccc`，该条件可以在a和b中间满足，也可以在b和c中间满足。

因此我们无法是使用「二分」，相应的也无法直接使用「滑动窗口」思路的双指针。

因为双指针其实也是利用了二段性质，当一个指针确定在某个位置，另外一个指针能够落在某个明确的分割点，使得左半部分满足，右半部分不满足。

**那么还有什么性质可以利用呢？这时候要留意数据范围「数值小」的内容。**

题目说明了只包含小写字母（26 个，为有限数据），**我们可以枚举最大长度所包含的字符类型数量，答案必然是 [1, 26]，即最少包含 1 个字母，最多包含 26 个字母。**

你会发现，**当确定了长度所包含的字符种类数量时，区间重新具有了二段性质。**

当我们使用双指针的时候：

1. 右端点往右移动必然会导致字符类型数量增加（或不变）
2. 左端点往右移动必然会导致字符类型数量减少（或不变）

当然，我们还需要记录有多少字符符合要求（出现次数不少于 k），当区间内所有字符都符合时更新答案。

代码：

```c++
class Solution {
public:
    int longestSubstring(string s, int k) {
        int ans = 0;
        int n = s.size();
        for (int p = 1; p <= 26; p++) {
            vector<int> window(26, 0);
            int i = 0, j = 0;
            int num_elem = 0, count = 0;
            while (j < n) {
                window[s[j] - 'a']++;
                if (window[s[j] - 'a'] == 1) {
                    num_elem++;
                }
                if (window[s[j] - 'a'] == k) {
                    count++;
                }
                j++;
                while (num_elem > p) {
                    window[s[i] - 'a']--;
                    if (window[s[i] - 'a'] == 0) {
                        num_elem--;
                    }
                    if (window[s[i] - 'a'] == k - 1) {
                        count--;
                    }
                    i++;
                }

                if (num_elem == count) {
                    ans = max(ans, j - i);
                }
            }
        }

        return ans;
    }
};
```