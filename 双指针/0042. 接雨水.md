#### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

难度`困难`

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

**提示：**

- `n == height.length`
- `1 <= n <= 2 * 104`
- `0 <= height[i] <= 105`

---

#### 双指针 -> 动态规划

对于每根柱子而言，我们只需要找出「其左边最高的柱子」和「其右边最高的柱子」。

对左右的最高柱子取一个最小值，再和当前柱子的高度做一个比较，即可得出当前位置可以接下的雨水。

同时，边缘的柱子不可能接到雨水（某一侧没有柱子）。

朴素解法的思路有了，我们想想怎么优化。

事实上，任何的优化无非都是「减少重复」。

想想在朴素思路中有哪些环节比较耗时，耗时环节中又有哪些地方是重复的，可以优化的。

首先对每根柱子进行遍历，求解每根柱子可以接下多少雨水，这个 O(n) 操作肯定省不了。

**但在求解某根柱子可以接下多少雨水时，需要对两边进行扫描，求两侧的最大值。每一根柱子都进行这样的扫描操作，导致每个位置都被扫描了 n 次。这个过程显然是可优化的。**

换句话说：**我们希望通过不重复遍历的方式找到任意位置的两侧最大值。**

问题转化为：**给定一个数组，如何求得任意位置的左半边的最大值和右半边的最大值。**

一个很直观的方案是：**直接将某个位置的两侧最大值存起来。**

我们可以先从两端分别出发，预处理每个位置的「左右最值」，这样可以将我们「查找左右最值」的复杂度降到 O(1)。

整体算法的复杂度也从 O(n2) 下降到 O(n)。

代码：

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (n == 0) {
            return 0;
        }

        int left_max[n];
        int right_max[n];

        left_max[0] = height[0];
        for (int i = 1; i < n; i++) {
            left_max[i] = max(left_max[i - 1], height[i]);
        }

        right_max[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            right_max[i] = max(right_max[i + 1], height[i]);
        }

        int result = 0;
        for (int i = 0; i < n; i++) {
            result += max(0, min(left_max[i], right_max[i]) - height[i]);
        }

        return result;
    }
};

```

